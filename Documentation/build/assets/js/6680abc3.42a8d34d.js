"use strict";(self.webpackChunkeliza_docs=self.webpackChunkeliza_docs||[]).push([[60896],{39351:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"core/agents","title":"\ud83e\udd16 Agents","description":"Agents are the core components of the Eliza framework that handle autonomous interactions. Each agent runs in a runtime environment and can interact through various clients (Discord, Telegram, etc.) while maintaining consistent behavior and memory.","source":"@site/docs/core/agents.md","sourceDirName":"core","slug":"/core/agents","permalink":"/eliza/docs/core/agents","draft":false,"unlisted":false,"editUrl":"https://github.com/ai16z/eliza/tree/main/docs/docs/core/agents.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Character Files","permalink":"/eliza/docs/core/characterfile"},"next":{"title":"Providers","permalink":"/eliza/docs/core/providers"}}');var r=s(62540),a=s(43023);const i={sidebar_position:2},o="\ud83e\udd16 Agents",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Core Components",id:"core-components",level:2},{value:"AgentRuntime Interface",id:"agentruntime-interface",level:3},{value:"Creating an Agent Runtime",id:"creating-an-agent-runtime",level:2},{value:"State Management",id:"state-management",level:2},{value:"Memory Systems",id:"memory-systems",level:2},{value:"Message Processing",id:"message-processing",level:2},{value:"Services and Memory Management",id:"services-and-memory-management",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Evaluation System",id:"evaluation-system",level:2},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-agents",children:"\ud83e\udd16 Agents"})}),"\n",(0,r.jsx)(n.p,{children:"Agents are the core components of the Eliza framework that handle autonomous interactions. Each agent runs in a runtime environment and can interact through various clients (Discord, Telegram, etc.) while maintaining consistent behavior and memory."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"/api/classes/AgentRuntime",children:"AgentRuntime"})," class is the primary implementation of the ",(0,r.jsx)(n.a,{href:"/api/interfaces/IAgentRuntime",children:"IAgentRuntime"})," interface, which manages the agent's core functions, including:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message and Memory Processing"}),": Storing, retrieving, and managing conversation data and contextual memory."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Management"}),": Composing and updating the agent\u2019s state for a coherent, ongoing interaction."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Action Execution"}),": Handling behaviors such as transcribing media, generating images, and following rooms."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Evaluation and Response"}),": Assessing responses, managing goals, and extracting relevant information."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.p,{children:"Each agent runtime consists of key components that enable flexible and extensible functionality:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clients"}),": Enable communication across platforms such as Discord, Telegram, and Direct (REST API), with features tailored for each platform."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Providers"}),": Extend the agent\u2019s capabilities by integrating with additional services (e.g., time, wallet, or custom data)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Actions"}),": Define agent behaviors, such as following rooms, generating images, or processing attachments. Custom actions can be created to tailor behaviors to specific needs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Evaluators"}),": Manage agent responses by assessing message relevance, managing goals, extracting facts, and building long-term memory."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"agentruntime-interface",children:"AgentRuntime Interface"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"IAgentRuntime"})," interface defines the main structure of the runtime environment, specifying the configuration and essential components:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface IAgentRuntime {\n  // Core identification\n  agentId: UUID;\n  serverUrl: string;\n  token: string;\n\n  // Configuration\n  character: Character;\n  modelProvider: ModelProviderName;\n\n  // Components\n  actions: Action[];\n  evaluators: Evaluator[];\n  providers: Provider[];\n\n  // Database & Memory\n  databaseAdapter: IDatabaseAdapter;\n  messageManager: IMemoryManager;\n  descriptionManager: IMemoryManager;\n  loreManager: IMemoryManager;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Each element in the runtime interface plays a crucial role:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Identification"}),": Agent ID, server URL, and token for authentication and identification."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration"}),": Character profile and model provider define the agent's personality and language model."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Components"}),": Actions, evaluators, and providers support extensible behaviors, response evaluation, and service integration."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Management"}),": Specialized memory managers track conversations, descriptions, and static knowledge to enable contextual and adaptive responses."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"creating-an-agent-runtime",children:"Creating an Agent Runtime"}),"\n",(0,r.jsx)(n.p,{children:"This section demonstrates setting up an agent with basic and optional configurations. It provides a working example and sample code that helps users quickly start building:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { AgentRuntime, ModelProviderName } from "@ai16z/eliza";\n\n// Configuration example\nconst runtime = new AgentRuntime({\n  token: "auth-token",\n  modelProvider: ModelProviderName.ANTHROPIC,\n  character: characterConfig,\n  databaseAdapter: new DatabaseAdapter(),\n  conversationLength: 32,\n  serverUrl: "http://localhost:7998",\n  actions: customActions,\n  evaluators: customEvaluators,\n  providers: customProviders,\n});\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"state-management",children:"State Management"}),"\n",(0,r.jsxs)(n.p,{children:["This section should cover how agents manage and update state, with a focus on initial state composition and updating methods. The runtime maintains state through the ",(0,r.jsx)(n.a,{href:"/api/interfaces/state",children:"State"})," interface:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface State {\n  userId?: UUID;\n  agentId?: UUID;\n  roomId: UUID;\n  bio: string;\n  lore: string;\n  agentName?: string;\n  senderName?: string;\n  actors: string;\n  actorsData?: Actor[];\n  recentMessages: string;\n  recentMessagesData: Memory[];\n  goals?: string;\n  goalsData?: Goal[];\n  actions?: string;\n  actionNames?: string;\n  providers?: string;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"State composition and updates are handled through dedicated methods:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Compose initial state\nconst state = await runtime.composeState(message, {\n  additionalContext: "custom-context",\n});\n\n// Update message state\nconst updatedState = await runtime.updateRecentMessageState(state);\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best practices"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep state immutable where possible"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"composeState"})," for initial state creation"]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"updateRecentMessageState"})," for updates"]}),"\n",(0,r.jsx)(n.li,{children:"Cache frequently accessed state data"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"memory-systems",children:"Memory Systems"}),"\n",(0,r.jsx)(n.p,{children:"The Eliza framework uses multiple types of memory to support an agent's long-term engagement, contextual understanding, and adaptive responses. Each type of memory serves a specific purpose:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Message History"}),": Stores recent conversations to provide continuity within a session. This helps the agent maintain conversational context and avoid repetitive responses within short-term exchanges."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Factual Memory"}),": Holds specific, context-based facts about the user or environment, such as user preferences, recent activities, or specific details mentioned in previous interactions. This type of memory enables the agent to recall user-specific information across sessions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Knowledge Base"}),": Contains general knowledge the agent might need to respond to broader queries or provide informative answers. This memory is more static, helping the agent retrieve pre-defined data, common responses, or static character lore."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Relationship Tracking"}),": Manages the agent\u2019s understanding of its relationship with users, including details like user-agent interaction frequency, sentiment, and connection history. It is particularly useful for building rapport and providing a more personalized interaction experience over time."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RAG Integration"}),": Uses a vector search to perform contextual recall based on similarity matching. This enables the agent to retrieve relevant memory snippets or knowledge based on the content and intent of the current conversation, making its responses more contextually relevant."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The runtime uses multiple specialized ",(0,r.jsx)(n.a,{href:"/api/interfaces/IMemoryManager",children:"IMemoryManager"})," instances:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"messageManager"})," - conversation messages and responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"descriptionManager"})," - user descriptions and profiles"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"loreManager"})," - static character knowledge"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"message-processing",children:"Message Processing"}),"\n",(0,r.jsxs)(n.p,{children:["The runtime's message processing is handled through the ",(0,r.jsx)(n.a,{href:"/api/classes/AgentRuntime#processactions",children:"processActions"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Process message with actions\nawait runtime.processActions(message, responses, state, async (newMessages) => {\n  // Handle new messages\n  return [message];\n});\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"services-and-memory-management",children:"Services and Memory Management"}),"\n",(0,r.jsxs)(n.p,{children:["Services are managed through the ",(0,r.jsx)(n.a,{href:"/api/classes/AgentRuntime#getservice",children:"getService"})," and ",(0,r.jsx)(n.a,{href:"/api/classes/AgentRuntime#registerservice",children:"registerService"})," methods:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Register service\nruntime.registerService(new TranscriptionService());\n\n// Get service\nconst service = runtime.getService<ITranscriptionService>(\n  ServiceType.TRANSCRIPTION,\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsxs)(n.p,{children:["Memory managers are accessed via ",(0,r.jsx)(n.a,{href:"/api/classes/AgentRuntime#getmemorymanager",children:"getMemoryManager"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Get memory manager\nconst memoryManager = runtime.getMemoryManager("messages");\n\n// Create memory\nawait memoryManager.createMemory({\n  id: messageId,\n  content: { text: "Message content" },\n  userId: userId,\n  roomId: roomId,\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best practices"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use appropriate memory managers for different data types"}),"\n",(0,r.jsx)(n.li,{children:"Consider memory limits when storing data, regularly clean up memory"}),"\n",(0,r.jsxs)(n.li,{children:["Use the ",(0,r.jsx)(n.code,{children:"unique"})," flag for deduplicated storage"]}),"\n",(0,r.jsx)(n.li,{children:"Clean up old memories periodically"}),"\n",(0,r.jsx)(n.li,{children:"Use immutability in state management."}),"\n",(0,r.jsx)(n.li,{children:"Log errors and maintain stability during service failures."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"evaluation-system",children:"Evaluation System"}),"\n",(0,r.jsxs)(n.p,{children:["The runtime's ",(0,r.jsx)(n.a,{href:"/api/classes/AgentRuntime#evaluate",children:"evaluate"})," method processes evaluations:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Evaluate message\nconst evaluationResults = await runtime.evaluate(message, state, didRespond);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Processing"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"await runtime.processActions(message, responses, state, (newMessages) => {\n  return [message];\n});\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Management"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const state = await runtime.composeState(message, {\n  additionalContext: "custom-context",\n});\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory Management"}),":"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const memoryManager = runtime.getMemoryManager("messages");\nawait memoryManager.createMemory({\n  id: messageId,\n  content: { text: "Message content" },\n  userId,\n  roomId,\n});\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/eliza/docs/core/actions",children:"Actions Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/eliza/docs/core/evaluators",children:"Evaluators Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/eliza/docs/core/providers",children:"Providers Documentation"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api",children:"Full API Reference"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},43023:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var t=s(63696);const r={},a=t.createContext(r);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);